\CD "calloc" 0 D=C;
\RD "read" 0 D=R;

1000 1 C =h;
1000 h 1 R;;;
&&-=z

(256 z C) =i;    "iset";
(256 z C) =v;    "val";
((266 z C) (256 z *) +) =s;  "stack";
((266 z C) (256 z *) +) =t;  "return stack";
s=x

{] z*+^}
{' r++;r$}
{I z* i+=j j=^}

"inop";
0=j (j 256 <? "{}" j I j++; @)

"ivar";
"{
  sz-=s
  v[p$]s=^
}"=d
'a=j (j'z <=? dj I j++; @)

"idigit";
"{ 
    0=j
    (p$ '0 >=?
     p$ '9 <=?
        ((j 10 *) (p$ '0 -) +) =j
        p++;
    @)
    (s z -)=s
    js=^
}"=d
'0=j (j'9 <=? dj I j++; @)

"istring";
"{ 
    sz-=s
    p++;
    ps=^
    (p$ 0 ==? } : p$ 34 !=? p++; @)
    0p=$
}" '" I

"ipop";
"{ sz+=s }" '; I

"ieq";
"{
    p++;
    (p$ '= ==?
        s^ sz+=s; s^ == s=^
    :(p$ '$ ==?
        sz+$ s^ =$ sz+z+=s
    :(p$ '^ ==?
        sz+^ s^ =^ sz+z+=s
    :(p$ '& ==?
        s^=s
    :
        s^ vp$z*+ =^ sz+=s
    ))))
}" '= I

"inot";
"{
    s^
    (p1+$ '= ==? sz+=s s^ != p++; : ! )
    s=^
}" '! I

"igt";
"{
    s^ sz+=s s^
    (p1+$ '= ==? <= p++; : < )
    s=^
}" '> I

"ilt";
"{
    s^ sz+=s s^
    (p1+$ '= ==? >= p++; : > )
    s=^
}" '< I

"iadd XXX";
"{ ((s[1] s^ +) ((s z +) =s) s=^)}" '+ I

"isub XXX";
"{ ((s[1] s^ -) ((s z +) =s) s=^)}" '- I

"imul";
"{ s^ sz+=s s^ * s=^ }" '* I

"idiv";
"{ s[1] s^ / sz+=s s=^ }" '/ I

"imod";
"{ s[1] s^ % sz+=s s=^ }" '% I

"ifwd";
"{
}" ': I

"iback";
"{
}" '@ I

"icond";
"{
}" '? I

"icall";

"iptr";
"{
}" '^ I

"icptr";
"{
}" '$ I

"iaddr";
"{
}" '& I

"ifun";
"{
}" '{ I

"iret";
"{
}" '} I

"iremap";
"{
}" '\ I



"isys XXX";
"{ s[6] s[5] s[4] s[3] s[2] s[1] s^ P;;;;;;; }" 'P I

{f}
h=p 
(p$ ?
    i[p$]=f 

    10 
    s[3] s[2] s[1] s^ 
    ((s z /) (x z /) -) p$ 
    "----[%c] stack %2ld; [%p, %p, %p, %p]%c"
    P;;;;;;;;

    f

    p++; 
@)

10 s^ "%d!!!%c"P;;

E
